// [Fog-Graphics]
//
// [License]
// MIT, See COPYING file in package

// [Guard]
#ifndef _FOG_GRAPHICS_PAINTENGINE_RASTERPAINTBASE_P_H
#define _FOG_GRAPHICS_PAINTENGINE_RASTERPAINTBASE_P_H

// [Dependencies]
#include <Fog/Core/Assert.h>
#include <Fog/Core/Atomic.h>
#include <Fog/Core/MemoryAllocator_p.h>
#include <Fog/Core/Static.h>
#include <Fog/Graphics/Constants.h>
#include <Fog/Graphics/Geometry.h>
#include <Fog/Graphics/Span_p.h>
#include <Fog/Graphics/RasterEngine_p.h>

namespace Fog {

//! @addtogroup Fog_Graphics_Private
//! @{

// ============================================================================
// [Configuration]
// ============================================================================

// Debugging.
// #define FOG_DEBUG_RASTER_SYNCHRONIZATION
// #define FOG_DEBUG_RASTER_COMMANDS
// #define FOG_DEBUG_RASTER_MASK

// Minimum size to set multithreading on.
enum { RASTER_MIN_SIZE_THRESHOLD = 128*128 };

// Maximum number of threads to use for rendering.
enum { RASTER_MAX_WORKERS = 16 };

// Maximum commands to accumulate in the buffer.
#if defined(FOG_DEBUG_RASTER_SYNCHRONIZATION)
// For debugging it's better to have only minimal buffer size for the commands
// and calculations.
enum { RASTER_MAX_COMMANDS = 32 };
#else
enum { RASTER_MAX_COMMANDS = 1024 };
#endif // FOG_DEBUG_RASTER_SYNCHRONIZATION

// Maximum calculations to accumulate in the buffer, at this time it must be
// the same as the maximum count of commands. The reason is that each command
// can use exactly one calculation so if you need serialize RASTER_MAX_COMMANDS
// you need also RASTER_MAX_COMMANDS possible calculations.
enum { RASTER_MAX_CALCULATIONS = RASTER_MAX_COMMANDS };

// Granularity of pool allocator.
//
// GRanularity means pool allocator step. For example if granularity is 16,
// then for span which length is 8 pixels will be allocated span at length 16.
// For span that needs 31 pixels will be allocated span at maximum capacity 32
// pixels, etc... (16, 32, 48, ...).
//
// Because span structure is relatevely long (20 or 28 bytes?) then it makes
// no sense to limit granularity too much, 16 or 32 are acceptable numbers.
//
// NOTE: This number must be exponent of two!
enum { RASTER_CLIP_VSPAN_POOL_GRANULARITY_BASE = 16 };
enum { RASTER_CLIP_VSPAN_POOL_GRANULARITY_SHIFT = 4 }; // 2^4 == 16

// Count of raster vspan pools (16 is enough).
enum { RASTER_CLIP_VSPAN_POOL_COUNT = 16 };

// Maximum size of span that can be generated by clipper, larger spans are
// split into two or more ones. This simplifies and improves the clipper memory
// management, because we are using pooling.
enum { RASTER_CLIP_VSPAN_MAX_SIZE =
  RASTER_CLIP_VSPAN_POOL_GRANULARITY_BASE * RASTER_CLIP_VSPAN_POOL_COUNT };

// ============================================================================
// [Fog::RASTER_LAYER_TYPE]
// ============================================================================

//! @internal
//!
//! @brief Type of current painter layer
enum RASTER_LAYER_TYPE
{
  //! @brief Non-initialized.
  RASTER_LAYER_NONE = 0,

  //! @brief Direct 32-bit painting and compositing (PRGB32, XRGB32).
  //!
  //! This layer is the most efficient layer in Fog-Framework.
  //!
  //! Pixel format summary:
  //! - @c IMAGE_FORMAT_PRGB32.
  //! - @c IMAGE_FORMAT_XRGB32.
  RASTER_LAYER_DIRECT32 = 1,

  //! @brief Indirect 32-bit painting and compositing (ARGB32).
  //!
  //! This layer is less efficient than @c RASTER_LAYER_DIRECT32, because each
  //! pixel needs to be premultiplied before compositing and demultiplied back
  //! after it has been processed. There are some optimizations, but generally
  //! this layer type should be avoided if possible.
  //!
  //! Pixel format summary:
  //! - @c IMAGE_FORMAT_ARGB32.
  RASTER_LAYER_INDIRECT32 = 2,

  //! @brief Direct 8-bit painting and compositing (A8).
  //!
  //! Pixel format summary:
  //! - @c IMAGE_FORMAT_A8.
  RASTER_LAYER_DIRECT8 = 3
};

// ============================================================================
// [Fog::RASTER_TRANSFORM_TYPE]
// ============================================================================

//! @internal
//!
//! @brief Type of current transform in raster paint engine.
enum RASTER_TRANSFORM_TYPE
{
  //! @brief Transformation matrix is identity or translation only.
  //!
  //! If translation part of matrix is used the values are aligned to pixel
  //! grid (this means that integral numbers can be used for this part). This
  //! is most efficient transform type in simple cases (fill rect, blit image,
  //! etc...).
  RASTER_TRANSFORM_EXACT = 0,

  //! @brief Transformation matrix is identity except translation part which
  //! can be represented only by real numbers. Painter has complex fast paths
  //! for this type, but it's used mainly by image blitting and texture
  //! fetching.
  RASTER_TRANSFORM_SUBPX = 1,

  //! @brief Transformation matrix is affine (not identity or simple translation).
  RASTER_TRANSFORM_AFFINE = 2
};

// ============================================================================
// [Fog::RASTER_CLIP_TYPE]
// ============================================================================

//! @internal
//!
//! @brief Clip type (masks).
//!
//! Possible combinations are:
//! - @c RASTER_CLIP_NULL - This can happen, painting is disabled (there is
//!   no area where to paint. Together with this flag the painter state
//!   should also have also set related RASTER_STATE_NO_PAINT_... flags.
//! - @c RASTER_CLIP_SIMPLE - Simple clip region (rectangle).
//! - @c RASTER_CLIP_REGION - Complex clip region (set of rectangles).
//! - @c RASTER_CLIP_MASK - Mask clip.
enum RASTER_CLIP_TYPE
{
  //! @brief Null clip (no paint).
  RASTER_CLIP_NULL = 0,

  //! @brief Clip is very simple - one rectangle (@c BoxI instance).
  //!
  //! This flag is never set together with @c RASTER_CLIP_REGION, only one flag
  //! can be set at the time.
  RASTER_CLIP_SIMPLE = 1,

  //! @brief Clip is set of rectangles - region (always called as complex clip).
  //!
  //! This flag is never set together with @c RASTER_CLIP_SIMPLE, only one flag
  //! can be set at the time.
  RASTER_CLIP_REGION = 2,

  //! @brief Clip region contains mask.
  //!
  //! This is addition to @c RASTER_CLIP_SIMPLE and @c RASTER_CLIP_REGION flags.
  RASTER_CLIP_MASK = 3
};

// These constants are used by the macros inside raster paint engine, we need
// to make them available by the preprocessor.
#define RASTER_CLIP_SIMPLE 1
#define RASTER_CLIP_REGION 2
#define RASTER_CLIP_MASK 3

// ============================================================================
// [Fog::RASTER_STATE_FLAGS]
// ============================================================================

//! @internal
//!
//! @brief State flags (contains no-paint flags and clip flags in one variable).
//!
//! No-paint flags - flags that will be set if some internal state disables
//! painting, see flags and their meanings for details.
//!
//! Pending flags - flags used to send particular commands to workers. All
//! flags are grouped together and when needed the command is sent. Commands
//! are generally not generated when it's not needed. For example if you save
//! clip state using save() and then restore() it and there weren't made
//! changes, then save and restore commands are not send to workers, because
//! they are not needed.
//!
//! Error flags - flags used to disable entire painting, because some fatal
//! error happened, there is only one flag - @c RASTER_STATE_FATAL_ERROR.
enum RASTER_STATE_FLAGS
{
  // --------------------------------------------------------------------------
  // [No-Paint Flags]
  // --------------------------------------------------------------------------

  //! @brief Mask including all no-paint states including fatal error.
  RASTER_STATE_NO_PAINT_MASK = 0x8000FFFF,

  //! @brief Painting is disabled due to operator (for example @c OPERATOR_DST
  //! is not).
  RASTER_STATE_NO_PAINT_OPERATOR = 0x00000001,

  //! @brief Painting is disabled due to source (for example empty texture).
  RASTER_STATE_NO_PAINT_SOURCE = 0x00000002,

  //! @brief Painting is disabled, because the global painter alpha value is
  //! too low (near 0.0).
  RASTER_STATE_NO_PAINT_ALPHA = 0x00000004,

  //! @brief Painting is disabled, because transformation matrix is invalid or
  //! degenerated (for example matrix where one of scale value is 0.0).
  RASTER_STATE_NO_PAINT_MATRIX = 0x00000008,

  //! @brief Painting is disabled due to meta or user clipping region (there is
  //! no area to paint into).
  RASTER_STATE_NO_PAINT_WORK_REGION = 0x00000010,

  //! @brief Painting is disabled due to meta or user clipping region (there is
  //! no area to paint into).
  RASTER_STATE_NO_PAINT_FINAL_REGION = 0x00000020,

  //! @brief Painting is disabled due to clip mask.
  RASTER_STATE_NO_PAINT_CLIP_MASK = 0x00000040,

  // --------------------------------------------------------------------------
  // [Pending Flags - TOP-TO-BOTTOM Order]
  // --------------------------------------------------------------------------

  //! @brief Mask that contains all pending states.
  RASTER_STATE_PENDING_MASK = 0x7FFF0000,

  //! @brief Clipping was changed so the first paint call (that is likely to
  //! paint something) must ensure to call methods that will send the changes
  //! to the workers (making command). If not running in multithreaded mode
  //! then this flag shouldn't be set.
  RASTER_STATE_PENDING_CLIP_REGION = 0x00010000,

  //! @brief Clip state need to be saved (send the command to the workers).
  RASTER_STATE_PENDING_CLIP_SAVE = 0x00020000,

  //! @brief Clip mask initialization is pending.
  RASTER_STATE_PENDING_CLIP_MASK_CREATED = 0x00040000,

  //! @brief Clip state need to be restored (send the command to the workers).
  RASTER_STATE_PENDING_CLIP_MASK_DELETED = 0x00080000,

  // --------------------------------------------------------------------------
  // [Fatal Error]
  // --------------------------------------------------------------------------

  //! @brief Painting is disabled, because something bad happened, for example
  //! memory allocation error for core objects. This error can be cleared only
  //! by @c Painter::switchTo(), @c endLayer() methods.
  //!
  //! This is fatal error that can disable all painting until the paint engine
  //! is destroyed.
  RASTER_STATE_FATAL_ERROR = 0x80000000
};

// ============================================================================
// [Fog::RASTER_COMMAND_STATUS]
// ============================================================================

//! @internal
//!
//! @brief Status of the raster paint engine command.
//!
//! Status of command is only used if it has associated calculation.
enum RASTER_COMMAND_STATUS
{
  //! @brief Wait until calculation is done.
  RASTER_COMMAND_WAIT = 0,

  //! @brief Ready to process the command.
  RASTER_COMMAND_READY = 1,

  //! @brief Skip this command - don't call @c RasterPaintAction::run().
  RASTER_COMMAND_SKIP = 2
};

// ============================================================================
// [Fog::RasterClipVSpan]
// ============================================================================

#include <Fog/Core/Pack/PackByte.h>
//! @internal
//!
//! @brief Raster paint engine span managed by clip-manager.
//!
//! This structure extends classic @c Span8 with 'len' and 'poolId' members that
//! describes span length and the pool used by the clip-manager.
struct FOG_HIDDEN RasterClipVSpan8 : public Span8
{
  //! @brief Maximum length of span in pixels.
  uint len : 24;
  //! @brief Span allocator category
  uint poolId : 8;
};
#include <Fog/Core/Pack/PackRestore.h>

// ============================================================================
// [Fog::RasterClipMask]
// ============================================================================

//! @internal
//!
//! @brief Clip mask.
//!
//! Clip mask is always allocated from main thread, but can be freed by any
//! other thread when it's no longer in use. Clipping management is connected
//! to state management and it's based on FIFO solution.
//!
//! @section Clipping and multithreading
//!
//! Multithreaded clipping is inplemented by the same way as singlethreaded,
//! but commands and calculations are used to tell threads what to do. There
//! are also commands for state-management thats unique to the mask-clipping
//! (and only used by the mask-clipping).
//!
//! @section Snapshots.
//!
//! Mask-clipping management is based on the snapshots. Snapshots are very
//! similar to ones contained in @c ZoneMemoryManager, but improved to handle
//! pool buffers and additional data. Snapshot is only used when needed. For
//! example if you save() painter state and do some work that is not related
//! to clipping then snapshot-management is NOT used. Also if you change
//! clipping type to another (using @c CLIP_OP_REPLACE operator) then the
//! snapshot is not created. Snapshot is always created with new mask and
//! describes the state before the mask was created (previous mask data).
struct FOG_HIDDEN RasterClipMask
{
  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! @brief Reference count (when it goes to zero then mask should be destroyed).
  //!
  //! Saving mask to state increases the reference count.
  mutable Atomic<uint> refCount;

  //! @brief Mask ID.
  uint id;

  //! @brief Whether the mask was saved.
  //!
  //! Only used by the master context, clip state management and serializers. If
  //! the clip command is being serialized and saved is larger than zero then new
  //! @c RasterClipMask must be created.
  uint saved;

  //! @brief Work clip box, copied from master.
  BoxI workBox;

  //! @brief Work width (minimal width of allocated mask per row).
  uint width;
  //! @brief Work height.
  uint height;

  //! @brief Spans data, first span - spans[0] is pointer to span at physical
  //! position workBox.y1 in raster. It's to save space and to be correct.
  //! (I don't like buggy pointers, the pointer is adjusted in the code).
  //!
  //! To access the spans use always @c getSpansAt() method.
  //!
  //! Length of array is workBox.getHeight().
  Span8** spans;
};

// ============================================================================
// [Fog::RasterClipSnapshot]
// ============================================================================

//! @internal
//!
//! @brief Saved clip-mask snapshot.
//!
//! This structure is used to hold some data needed to save / restore clip-mask.
//! It's managed by the clipper and state manager.
struct FOG_HIDDEN RasterClipSnapshot
{
  //! @brief Previous snapshot (can be @c NULL if this is the first one).
  RasterClipSnapshot* prev;

  //! @brief Pointer to the related mask.
  RasterClipMask* mask;

  //! @brief Type of snapshot, see @c RASTER_SNAPSHOT_TYPE.
  uint type;

  //! @brief Saved maskY1 value.
  int maskY1;
  //! @brief Saved maskY2 value.
  int maskY2;

  //! @bried Saved maskSpanAdj value.
  Span8** maskSpanAdj;

  //! @brief Saved mask span allocator record (will be restored with clip-mask).
  ZoneMemoryAllocator::Record* maskSpanRecord;

  //! @brief Saved clip CSpan pool (saving clip-mask causes reset).
  Span8* maskCSpanPool;

  //! @brief Saved clip VSpan pool (saving clip-mask causes reset).
  RasterClipVSpan8* maskVSpanPool[RASTER_CLIP_VSPAN_POOL_COUNT];
};

// ============================================================================
// [Fog::RasterPaintLayer]
// ============================================================================

//! @internal
//!
//! @brief Raster paint engine layer.
struct FOG_HIDDEN RasterPaintLayer
{
  //! @brief Pointer to first raster scanline.
  uint8_t* pixels;

  //! @brief Layer width.
  uint32_t width;
  //! @brief Layer height.
  uint32_t height;
  //! @brief Layer primary format - format of @c pixels.
  uint32_t format;
  //! @brief Layer bytes per pixel.
  uint32_t bytesPerPixel;
  //! @brief Layer stride (bytes per line including padding).
  sysint_t stride;

  //! @brief Type of layer.
  uint32_t type;
  //! @brief Layer secondary format - format of @c pixels converted by
  //! @c toSecondary() method.
  uint32_t secondaryFormat;

  //! @brief Convert pixels from primary format to pixels in secondary format
  //! (fill version).
  RasterVBlitFullFn toSecondaryFull;
  //! @brief Convert pixels from primary format to pixels in secondary format.
  //! (span version).
  RasterVBlitSpanFn toSecondarySpan;

  //! @brief Convert pixels from secondary format to pixels in primary format.
  //! (fill version).
  RasterVBlitFullFn fromSecondaryFull;
  //! @brief Convert pixels from secondary format to pixels in primary format.
  //! (span version)
  RasterVBlitSpanFn fromSecondarySpan;
};

// ============================================================================
// [Fog::RasterPaintOps]
// ============================================================================

//! @internal
//!
//! @brief Context paint ops (used by the master context and per worker context).
union FOG_HIDDEN RasterPaintOps
{
  struct
  {
    //! @brief Compositing operator, see @c OPERATOR_TYPE.
    uint32_t op : 8;

    //! @brief Type of source, see @c PAINTER_SOURCE_TYPE.
    uint32_t sourceType : 8;

    //! @brief Source format if source type is @c PAINTER_SOURCE_ARGB, possible
    //! values are @c IMAGE_FORMAT_PRGB32 or @c IMAGE_FORMAT_XRGB32.
    uint32_t sourceFormat : 8;

    //! @brief Paint alpha value from float to BYTE - 0 to 255 (including).
    uint32_t alpha255 : 8;
  };

  //! @brief All data packed in single integer.
  uint32_t data;
};

// ============================================================================
// [Fog::RasterPaintHints]
// ============================================================================

//! @internal
//!
//! @brief Context paint hints (used by the master context).
//!
//! Please do not treat this structure with @c Painter::setHint() and
//! @c Painter::getHint() methods. This structure contains useful hints
//! about the main context state.
union FOG_HIDDEN RasterPaintHints
{
  struct
  {
    //! @brief Type of transform, see @c RASTER_TRANSFORM_TYPE.
    uint32_t transformType : 8;

    //! @brief Fill rule, see @c FILL_RULE.
    uint32_t fillRule : 4;

    //! @brief Clip rule, see @c CLIP_RULE;
    uint32_t clipRule : 4;

    //! @brief Anti-aliasing type / quality, see @c ANTI_ALIASING_TYPE.
    uint32_t aaQuality : 4;

    //! @brief Image interpolation type / quality, see @c IMAGE_INTERPOLATION_TYPE.
    uint32_t imageInterpolation : 4;

    //! @brief Color interpolation type / quality, see @c COLOR_INTERPOLATION_TYPE.
    uint32_t colorInterpolation : 4;

    //! @brief Whether to force vector text rendering.
    uint32_t forceOutlineText : 1;

    //! @brief Whether line is simple (one pixel width and default caps).
    uint32_t lineIsSimple : 1;

    //! @brief Whether the mata matrix is used (this means that it's not identity
    //! matrix). Simple cases where meta matrix is not used are optimized.
    uint32_t metaTransformUsed : 1;
  };

  //! @brief All data packed in single integer.
  uint32_t data;
};

//! @}

} // Fog namespace

// [Guard]
#endif // _FOG_GRAPHICS_PAINTENGINE_RASTERPAINTBASE_P_H
